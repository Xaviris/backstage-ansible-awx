/// <reference types="react" />
import * as _backstage_core_plugin_api from '@backstage/core-plugin-api';
import { IconComponent, AnyApiFactory, AppTheme, AnyApiRef } from '@backstage/core-plugin-api';
import { JsonObject } from '@backstage/types';
import React, { JSX as JSX$1, ReactNode } from 'react';
import { z, ZodSchema, ZodTypeDef } from 'zod';

/**
 * Catch-all type for route params.
 *
 * @public
 */
type AnyRouteRefParams = {
    [param in string]: string;
} | undefined;

/**
 * Absolute route reference.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @public
 */
interface RouteRef<TParams extends AnyRouteRefParams = AnyRouteRefParams> {
    readonly $$type: '@backstage/RouteRef';
    readonly T: TParams;
}
/**
 * Create a {@link RouteRef} from a route descriptor.
 *
 * @param config - Description of the route reference to be created.
 * @public
 */
declare function createRouteRef<TParams extends {
    [param in TParamKeys]: string;
} | undefined = undefined, TParamKeys extends string = string>(config?: {
    /** A list of parameter names that the path that this route ref is bound to must contain */
    readonly params: string extends TParamKeys ? (keyof TParams)[] : TParamKeys[];
}): RouteRef<keyof TParams extends never ? undefined : string extends TParamKeys ? TParams : {
    [param in TParamKeys]: string;
}>;

/**
 * Descriptor of a route relative to an absolute {@link RouteRef}.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @public
 */
interface SubRouteRef<TParams extends AnyRouteRefParams = AnyRouteRefParams> {
    readonly $$type: '@backstage/SubRouteRef';
    readonly T: TParams;
    readonly path: string;
}
/**
 * Used in {@link PathParams} type declaration.
 * @ignore
 */
type ParamPart<S extends string> = S extends `:${infer Param}` ? Param : never;
/**
 * Used in {@link PathParams} type declaration.
 * @ignore
 */
type ParamNames<S extends string> = S extends `${infer Part}/${infer Rest}` ? ParamPart<Part> | ParamNames<Rest> : ParamPart<S>;
/**
 * This utility type helps us infer a Param object type from a string path
 * For example, `/foo/:bar/:baz` inferred to `{ bar: string, baz: string }`
 * @ignore
 */
type PathParams<S extends string> = {
    [name in ParamNames<S>]: string;
};
/**
 * Merges a param object type with an optional params type into a params object.
 * @ignore
 */
type MergeParams<P1 extends {
    [param in string]: string;
}, P2 extends AnyRouteRefParams> = (P1[keyof P1] extends never ? {} : P1) & (P2 extends undefined ? {} : P2);
/**
 * Convert empty params to undefined.
 * @ignore
 */
type TrimEmptyParams<Params extends {
    [param in string]: string;
}> = keyof Params extends never ? undefined : Params;
/**
 * Creates a SubRouteRef type given the desired parameters and parent route parameters.
 * The parameters types are merged together while ensuring that there is no overlap between the two.
 *
 * @ignore
 */
type MakeSubRouteRef<Params extends {
    [param in string]: string;
}, ParentParams extends AnyRouteRefParams> = keyof Params & keyof ParentParams extends never ? SubRouteRef<TrimEmptyParams<MergeParams<Params, ParentParams>>> : never;
/**
 * Create a {@link SubRouteRef} from a route descriptor.
 *
 * @param config - Description of the route reference to be created.
 * @public
 */
declare function createSubRouteRef<Path extends string, ParentParams extends AnyRouteRefParams = never>(config: {
    path: Path;
    parent: RouteRef<ParentParams>;
}): MakeSubRouteRef<PathParams<Path>, ParentParams>;

/**
 * Route descriptor, to be later bound to a concrete route by the app. Used to implement cross-plugin route references.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @public
 */
interface ExternalRouteRef<TParams extends AnyRouteRefParams = AnyRouteRefParams, TOptional extends boolean = boolean> {
    readonly $$type: '@backstage/ExternalRouteRef';
    readonly T: TParams;
    readonly optional: TOptional;
}
/**
 * Creates a route descriptor, to be later bound to a concrete route by the app. Used to implement cross-plugin route references.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @param options - Description of the route reference to be created.
 * @public
 */
declare function createExternalRouteRef<TParams extends {
    [param in TParamKeys]: string;
} | undefined = undefined, TOptional extends boolean = false, TParamKeys extends string = string>(options?: {
    /**
     * The parameters that will be provided to the external route reference.
     */
    readonly params?: string extends TParamKeys ? (keyof TParams)[] : TParamKeys[];
    /**
     * Whether or not this route is optional, defaults to false.
     *
     * Optional external routes are not required to be bound in the app, and
     * if they aren't, `useExternalRouteRef` will return `undefined`.
     */
    optional?: TOptional;
}): ExternalRouteRef<keyof TParams extends never ? undefined : string extends TParamKeys ? TParams : {
    [param in TParamKeys]: string;
}, TOptional>;

/**
 * TS magic for handling route parameters.
 *
 * @remarks
 *
 * The extra TS magic here is to require a single params argument if the RouteRef
 * had at least one param defined, but require 0 arguments if there are no params defined.
 * Without this we'd have to pass in empty object to all parameter-less RouteRefs
 * just to make TypeScript happy, or we would have to make the argument optional in
 * which case you might forget to pass it in when it is actually required.
 *
 * @public
 */
type RouteFunc<TParams extends AnyRouteRefParams> = (...[params]: TParams extends undefined ? readonly [] : readonly [params: TParams]) => string;
/**
 * React hook for constructing URLs to routes.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}
 *
 * @param routeRef - The ref to route that should be converted to URL.
 * @returns A function that will in turn return the concrete URL of the `routeRef`.
 * @public
 */
declare function useRouteRef<TOptional extends boolean, TParams extends AnyRouteRefParams>(routeRef: ExternalRouteRef<TParams, TOptional>): TParams extends true ? RouteFunc<TParams> | undefined : RouteFunc<TParams>;
/**
 * React hook for constructing URLs to routes.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}
 *
 * @param routeRef - The ref to route that should be converted to URL.
 * @returns A function that will in turn return the concrete URL of the `routeRef`.
 * @public
 */
declare function useRouteRef<TParams extends AnyRouteRefParams>(routeRef: RouteRef<TParams> | SubRouteRef<TParams>): RouteFunc<TParams>;

/**
 * React hook for retrieving dynamic params from the current URL.
 * @param _routeRef - Ref of the current route.
 * @public
 */
declare function useRouteRefParams<Params extends AnyRouteRefParams>(_routeRef: RouteRef<Params> | SubRouteRef<Params>): Params;

/** @public */
type ExtensionDataRef<TData, TConfig extends {
    optional?: true;
} = {}> = {
    id: string;
    T: TData;
    config: TConfig;
    $$type: '@backstage/ExtensionDataRef';
};
/** @public */
interface ConfigurableExtensionDataRef<TData, TConfig extends {
    optional?: true;
} = {}> extends ExtensionDataRef<TData, TConfig> {
    optional(): ConfigurableExtensionDataRef<TData, TData & {
        optional: true;
    }>;
}
/** @public */
declare function createExtensionDataRef<TData>(id: string): ConfigurableExtensionDataRef<TData>;

/** @public */
type NavTarget = {
    title: string;
    icon: IconComponent;
    routeRef: RouteRef<undefined>;
};
/** @public */
declare const coreExtensionData: {
    reactElement: ConfigurableExtensionDataRef<JSX$1.Element, {}>;
    routePath: ConfigurableExtensionDataRef<string, {}>;
    apiFactory: ConfigurableExtensionDataRef<AnyApiFactory, {}>;
    routeRef: ConfigurableExtensionDataRef<RouteRef<AnyRouteRefParams>, {}>;
    navTarget: ConfigurableExtensionDataRef<NavTarget, {}>;
    theme: ConfigurableExtensionDataRef<AppTheme, {}>;
};

/** @public */
type PortableSchema<TOutput> = {
    parse: (input: unknown) => TOutput;
    schema: JsonObject;
};

/** @public */
declare function createSchemaFromZod<TOutput, TInput>(schemaCreator: (zImpl: typeof z) => ZodSchema<TOutput, ZodTypeDef, TInput>): PortableSchema<TOutput>;

/**
 * Utility type to expand type aliases into their equivalent type.
 * @ignore
 */
type Expand<T> = T extends infer O ? {
    [K in keyof O]: O[K];
} : never;

/** @public */
interface ExtensionInput<TExtensionData extends AnyExtensionDataMap, TConfig extends {
    singleton: boolean;
    optional: boolean;
}> {
    $$type: '@backstage/ExtensionInput';
    extensionData: TExtensionData;
    config: TConfig;
}
/** @public */
declare function createExtensionInput<TExtensionData extends AnyExtensionDataMap, TConfig extends {
    singleton?: boolean;
    optional?: boolean;
}>(extensionData: TExtensionData, config?: TConfig): ExtensionInput<TExtensionData, {
    singleton: TConfig['singleton'] extends true ? true : false;
    optional: TConfig['optional'] extends true ? true : false;
}>;

/** @public */
type AnyRoutes = {
    [name in string]: RouteRef;
};
/** @public */
type AnyExternalRoutes = {
    [name in string]: ExternalRouteRef;
};
/** @public */
interface PluginOptions<Routes extends AnyRoutes, ExternalRoutes extends AnyExternalRoutes> {
    id: string;
    routes?: Routes;
    externalRoutes?: ExternalRoutes;
    extensions?: Extension<unknown>[];
}
/** @public */
interface BackstagePlugin<Routes extends AnyRoutes = AnyRoutes, ExternalRoutes extends AnyExternalRoutes = AnyExternalRoutes> {
    $$type: '@backstage/BackstagePlugin';
    id: string;
    extensions: Extension<unknown>[];
    routes: Routes;
    externalRoutes: ExternalRoutes;
}
/** @public */
declare function createPlugin<Routes extends AnyRoutes = {}, ExternalRoutes extends AnyExternalRoutes = {}>(options: PluginOptions<Routes, ExternalRoutes>): BackstagePlugin<Routes, ExternalRoutes>;

/** @public */
type AnyExtensionDataMap = {
    [name in string]: ExtensionDataRef<unknown, {
        optional?: true;
    }>;
};
/** @public */
type AnyExtensionInputMap = {
    [inputName in string]: ExtensionInput<AnyExtensionDataMap, {
        optional: boolean;
        singleton: boolean;
    }>;
};
/**
 * Converts an extension data map into the matching concrete data values type.
 * @public
 */
type ExtensionDataValues<TExtensionData extends AnyExtensionDataMap> = {
    [DataName in keyof TExtensionData as TExtensionData[DataName]['config'] extends {
        optional: true;
    } ? never : DataName]: TExtensionData[DataName]['T'];
} & {
    [DataName in keyof TExtensionData as TExtensionData[DataName]['config'] extends {
        optional: true;
    } ? DataName : never]?: TExtensionData[DataName]['T'];
};
/**
 * Converts an extension input map into the matching concrete input values type.
 * @public
 */
type ExtensionInputValues<TInputs extends {
    [name in string]: ExtensionInput<any, any>;
}> = {
    [InputName in keyof TInputs]: false extends TInputs[InputName]['config']['singleton'] ? Array<Expand<ExtensionDataValues<TInputs[InputName]['extensionData']>>> : false extends TInputs[InputName]['config']['optional'] ? Expand<ExtensionDataValues<TInputs[InputName]['extensionData']>> : Expand<ExtensionDataValues<TInputs[InputName]['extensionData']> | undefined>;
};
/** @public */
interface CreateExtensionOptions<TOutput extends AnyExtensionDataMap, TInputs extends AnyExtensionInputMap, TConfig> {
    id: string;
    attachTo: {
        id: string;
        input: string;
    };
    disabled?: boolean;
    inputs?: TInputs;
    output: TOutput;
    configSchema?: PortableSchema<TConfig>;
    factory(options: {
        source?: BackstagePlugin;
        config: TConfig;
        inputs: Expand<ExtensionInputValues<TInputs>>;
    }): Expand<ExtensionDataValues<TOutput>>;
}
/** @public */
interface Extension<TConfig> {
    $$type: '@backstage/Extension';
    id: string;
    attachTo: {
        id: string;
        input: string;
    };
    disabled: boolean;
    inputs: AnyExtensionInputMap;
    output: AnyExtensionDataMap;
    configSchema?: PortableSchema<TConfig>;
    factory(options: {
        source?: BackstagePlugin;
        config: TConfig;
        inputs: Record<string, undefined | Record<string, unknown> | Array<Record<string, unknown>>>;
    }): ExtensionDataValues<any>;
}
/** @public */
declare function createExtension<TOutput extends AnyExtensionDataMap, TInputs extends AnyExtensionInputMap, TConfig = never>(options: CreateExtensionOptions<TOutput, TInputs, TConfig>): Extension<TConfig>;

/** @public */
interface ExtensionOverridesOptions {
    extensions: Extension<unknown>[];
}
/** @public */
interface ExtensionOverrides {
    $$type: '@backstage/ExtensionOverrides';
}
/** @public */
declare function createExtensionOverrides(options: ExtensionOverridesOptions): ExtensionOverrides;

/**
 * The specification for this {@link AppNode} in the {@link AppTree}.
 *
 * @public
 * @remarks
 *
 * The specifications for a collection of app nodes is all the information needed
 * to build the tree and instantiate the nodes.
 */
interface AppNodeSpec {
    readonly id: string;
    readonly attachTo: {
        id: string;
        input: string;
    };
    readonly extension: Extension<unknown>;
    readonly disabled: boolean;
    readonly config?: unknown;
    readonly source?: BackstagePlugin;
}
/**
 * The connections from this {@link AppNode} to other nodes.
 *
 * @public
 * @remarks
 *
 * The app node edges are resolved based on the app node specs, regardless of whether
 * adjacent nodes are disabled or not. If no parent attachment is present or
 */
interface AppNodeEdges {
    readonly attachedTo?: {
        node: AppNode;
        input: string;
    };
    readonly attachments: ReadonlyMap<string, AppNode[]>;
}
/**
 * The instance of this {@link AppNode} in the {@link AppTree}.
 *
 * @public
 * @remarks
 *
 * The app node instance is created when the `factory` function of an extension is called.
 * Instances will only be present for nodes in the app that are connected to the root
 * node and not disabled
 */
interface AppNodeInstance {
    /** Returns a sequence of all extension data refs that were output by this instance */
    getDataRefs(): Iterable<ExtensionDataRef<unknown>>;
    /** Get the output data for a single extension data ref */
    getData<T>(ref: ExtensionDataRef<T>): T | undefined;
}
/**
 * A node in the {@link AppTree}.
 *
 * @public
 */
interface AppNode {
    /** The specification for how this node should be instantiated */
    readonly spec: AppNodeSpec;
    /** The edges from this node to other nodes in the app tree */
    readonly edges: AppNodeEdges;
    /** The instance of this node, if it was instantiated */
    readonly instance?: AppNodeInstance;
}
/**
 * The app tree containing all {@link AppNode}s of the app.
 *
 * @public
 */
interface AppTree {
    /** The root node of the app */
    readonly root: AppNode;
    /** A map of all nodes in the app by ID, including orphaned or disabled nodes */
    readonly nodes: ReadonlyMap<string, AppNode>;
    /** A sequence of all nodes with a parent that is not reachable from the app root node */
    readonly orphans: Iterable<AppNode>;
}
/**
 * The API for interacting with the {@link AppTree}.
 *
 * @public
 */
interface AppTreeApi {
    /**
     * Get the {@link AppTree} for the app.
     */
    getTree(): {
        tree: AppTree;
    };
}
/**
 * The `ApiRef` of {@link AppTreeApi}.
 *
 * @public
 */
declare const appTreeApiRef: _backstage_core_plugin_api.ApiRef<AppTreeApi>;

/** @public */
interface ExtensionBoundaryProps {
    id: string;
    source?: BackstagePlugin;
    routable?: boolean;
    children: ReactNode;
}
/** @public */
declare function ExtensionBoundary(props: ExtensionBoundaryProps): React.JSX.Element;

/** @public */
declare function createApiExtension<TConfig extends {}, TInputs extends AnyExtensionInputMap>(options: ({
    api: AnyApiRef;
    factory: (options: {
        config: TConfig;
        inputs: Expand<ExtensionInputValues<TInputs>>;
    }) => AnyApiFactory;
} | {
    factory: AnyApiFactory;
}) & {
    configSchema?: PortableSchema<TConfig>;
    inputs?: TInputs;
}): Extension<TConfig>;

/**
 * Helper for creating extensions for a routable React page component.
 *
 * @public
 */
declare function createPageExtension<TConfig extends {
    path: string;
}, TInputs extends AnyExtensionInputMap>(options: ({
    defaultPath: string;
} | {
    configSchema: PortableSchema<TConfig>;
}) & {
    id: string;
    attachTo?: {
        id: string;
        input: string;
    };
    disabled?: boolean;
    inputs?: TInputs;
    routeRef?: RouteRef;
    loader: (options: {
        config: TConfig;
        inputs: Expand<ExtensionInputValues<TInputs>>;
    }) => Promise<JSX.Element>;
}): Extension<TConfig>;

/**
 * Helper for creating extensions for a nav item.
 * @public
 */
declare function createNavItemExtension(options: {
    id: string;
    routeRef: RouteRef<undefined>;
    title: string;
    icon: IconComponent;
}): Extension<{
    title: string;
}>;

/** @public */
declare function createThemeExtension(theme: AppTheme): Extension<never>;

export { AnyExtensionDataMap, AnyExtensionInputMap, AnyExternalRoutes, AnyRouteRefParams, AnyRoutes, AppNode, AppNodeEdges, AppNodeInstance, AppNodeSpec, AppTree, AppTreeApi, BackstagePlugin, ConfigurableExtensionDataRef, CreateExtensionOptions, Extension, ExtensionBoundary, ExtensionBoundaryProps, ExtensionDataRef, ExtensionDataValues, ExtensionInput, ExtensionInputValues, ExtensionOverrides, ExtensionOverridesOptions, ExternalRouteRef, NavTarget, PluginOptions, PortableSchema, RouteFunc, RouteRef, SubRouteRef, appTreeApiRef, coreExtensionData, createApiExtension, createExtension, createExtensionDataRef, createExtensionInput, createExtensionOverrides, createExternalRouteRef, createNavItemExtension, createPageExtension, createPlugin, createRouteRef, createSchemaFromZod, createSubRouteRef, createThemeExtension, useRouteRef, useRouteRefParams };
