import { createApiRef, useApp, AnalyticsContext, useAnalytics } from '@backstage/core-plugin-api';
import React, { Component, Suspense, useEffect, lazy, useMemo } from 'react';
import { Button } from '@material-ui/core';
import { ErrorPanel } from '@backstage/core-components';
import { getOrCreateGlobalSingleton, useVersionedContext } from '@backstage/version-bridge';
import { z } from 'zod';
import zodToJsonSchema from 'zod-to-json-schema';
import { useLocation, useParams } from 'react-router-dom';

const appTreeApiRef = createApiRef({ id: "core.app-tree" });

var __defProp$3 = Object.defineProperty;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$3 = (obj, key, value) => {
  __defNormalProp$3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const DefaultErrorBoundaryFallback = ({
  plugin,
  error,
  resetError
}) => {
  const title = `Error in ${plugin == null ? void 0 : plugin.id}`;
  return /* @__PURE__ */ React.createElement(ErrorPanel, { title, error, defaultExpanded: true }, /* @__PURE__ */ React.createElement(Button, { variant: "outlined", onClick: resetError }, "Retry"));
};
class ErrorBoundary extends Component {
  constructor() {
    super(...arguments);
    __publicField$3(this, "state", { error: void 0 });
    __publicField$3(this, "handleErrorReset", () => {
      this.setState({ error: void 0 });
    });
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  render() {
    const { error } = this.state;
    const { plugin, children } = this.props;
    if (error) {
      return /* @__PURE__ */ React.createElement(
        DefaultErrorBoundaryFallback,
        {
          plugin,
          error,
          resetError: this.handleErrorReset
        }
      );
    }
    return children;
  }
}

function ExtensionSuspense(props) {
  const { children } = props;
  const app = useApp();
  const { Progress } = app.getComponents();
  return /* @__PURE__ */ React.createElement(Suspense, { fallback: /* @__PURE__ */ React.createElement(Progress, null) }, children);
}

getOrCreateGlobalSingleton(
  "core-plugin-api:analytics-tracker-events",
  () => ({
    mostRecentGatheredNavigation: void 0,
    mostRecentRoutableExtensionRender: void 0,
    beforeUnloadRegistered: false
  })
);
const routableExtensionRenderedEvent = "_ROUTABLE-EXTENSION-RENDERED";

const RouteTracker = (props) => {
  const { disableTracking, children } = props;
  const analytics = useAnalytics();
  useEffect(() => {
    if (disableTracking)
      return;
    analytics.captureEvent(routableExtensionRenderedEvent, "");
  }, [analytics, disableTracking]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
};
function ExtensionBoundary(props) {
  const { id, source, routable, children } = props;
  const attributes = {
    extension: id,
    pluginId: source == null ? void 0 : source.id
  };
  return /* @__PURE__ */ React.createElement(ExtensionSuspense, null, /* @__PURE__ */ React.createElement(ErrorBoundary, { plugin: source }, /* @__PURE__ */ React.createElement(AnalyticsContext, { attributes }, /* @__PURE__ */ React.createElement(RouteTracker, { disableTracking: !routable }, children))));
}

function createExtensionDataRef(id) {
  return {
    id,
    $$type: "@backstage/ExtensionDataRef",
    config: {},
    optional() {
      return { ...this, config: { ...this.config, optional: true } };
    }
  };
}

const coreExtensionData = {
  reactElement: createExtensionDataRef("core.reactElement"),
  routePath: createExtensionDataRef("core.routing.path"),
  apiFactory: createExtensionDataRef("core.api.factory"),
  routeRef: createExtensionDataRef("core.routing.ref"),
  navTarget: createExtensionDataRef("core.nav.target"),
  theme: createExtensionDataRef("core.theme")
};

function createExtension(options) {
  var _a, _b;
  return {
    ...options,
    disabled: (_a = options.disabled) != null ? _a : false,
    $$type: "@backstage/Extension",
    inputs: (_b = options.inputs) != null ? _b : {},
    factory({ inputs, ...rest }) {
      return options.factory({
        inputs,
        ...rest
      });
    }
  };
}

function createExtensionInput(extensionData, config) {
  return {
    $$type: "@backstage/ExtensionInput",
    extensionData,
    config: {
      singleton: Boolean(config == null ? void 0 : config.singleton),
      optional: Boolean(config == null ? void 0 : config.optional)
    }
  };
}

function createPlugin(options) {
  var _a, _b, _c;
  return {
    ...options,
    routes: (_a = options.routes) != null ? _a : {},
    externalRoutes: (_b = options.externalRoutes) != null ? _b : {},
    extensions: (_c = options.extensions) != null ? _c : [],
    $$type: "@backstage/BackstagePlugin"
  };
}

function createExtensionOverrides(options) {
  return {
    $$type: "@backstage/ExtensionOverrides",
    version: "v1",
    extensions: options.extensions
  };
}

function createApiExtension(options) {
  const { factory, configSchema, inputs: extensionInputs } = options;
  const apiRef = "api" in options ? options.api : factory.api;
  return createExtension({
    id: `apis.${apiRef.id}`,
    attachTo: { id: "core", input: "apis" },
    inputs: extensionInputs,
    configSchema,
    output: {
      api: coreExtensionData.apiFactory
    },
    factory({ config, inputs }) {
      if (typeof factory === "function") {
        return { api: factory({ config, inputs }) };
      }
      return { api: factory };
    }
  });
}

function createSchemaFromZod(schemaCreator) {
  const schema = schemaCreator(z);
  return {
    // TODO: Types allow z.array etc here but it will break stuff
    parse: (input) => {
      const result = schema.safeParse(input);
      if (result.success) {
        return result.data;
      }
      throw new Error(result.error.issues.map(formatIssue).join("; "));
    },
    // TODO: Verify why we are not compatible with the latest zodToJsonSchema.
    schema: zodToJsonSchema(schema)
  };
}
function formatIssue(issue) {
  if (issue.code === "invalid_union") {
    return formatIssue(issue.unionErrors[0].issues[0]);
  }
  let message = issue.message;
  if (message === "Required") {
    message = `Missing required value`;
  }
  if (issue.path.length) {
    message += ` at '${issue.path.join(".")}'`;
  }
  return message;
}

function createPageExtension(options) {
  var _a;
  const { id } = options;
  const configSchema = "configSchema" in options ? options.configSchema : createSchemaFromZod(
    (z) => z.object({ path: z.string().default(options.defaultPath) })
  );
  return createExtension({
    id,
    attachTo: (_a = options.attachTo) != null ? _a : { id: "core.routes", input: "routes" },
    configSchema,
    inputs: options.inputs,
    disabled: options.disabled,
    output: {
      element: coreExtensionData.reactElement,
      path: coreExtensionData.routePath,
      routeRef: coreExtensionData.routeRef.optional()
    },
    factory({ config, inputs, source }) {
      const ExtensionComponent = lazy(
        () => options.loader({ config, inputs }).then((element) => ({ default: () => element }))
      );
      return {
        path: config.path,
        routeRef: options.routeRef,
        element: /* @__PURE__ */ React.createElement(ExtensionBoundary, { id, source, routable: true }, /* @__PURE__ */ React.createElement(ExtensionComponent, null))
      };
    }
  });
}

function createNavItemExtension(options) {
  const { id, routeRef, title, icon } = options;
  return createExtension({
    id,
    attachTo: { id: "core.nav", input: "items" },
    configSchema: createSchemaFromZod(
      (z) => z.object({
        title: z.string().default(title)
      })
    ),
    output: {
      navTarget: coreExtensionData.navTarget
    },
    factory: ({ config }) => ({
      navTarget: {
        title: config.title,
        icon,
        routeRef
      }
    })
  });
}

function createThemeExtension(theme) {
  return createExtension({
    id: `themes.${theme.id}`,
    attachTo: { id: "core", input: "themes" },
    output: {
      theme: coreExtensionData.theme
    },
    factory: () => ({ theme })
  });
}

const MESSAGE_MARKER = "eHgtF5hmbrXyiEvo";
function describeParentCallSite(ErrorConstructor = Error) {
  const { stack } = new ErrorConstructor(MESSAGE_MARKER);
  if (!stack) {
    return "<unknown>";
  }
  const startIndex = stack.includes(MESSAGE_MARKER) ? stack.indexOf("\n") + 1 : 0;
  const secondEntryStart = stack.indexOf("\n", stack.indexOf("\n", startIndex) + 1) + 1;
  const secondEntryEnd = stack.indexOf("\n", secondEntryStart);
  const line = stack.substring(secondEntryStart, secondEntryEnd).trim();
  if (!line) {
    return "unknown";
  }
  if (line.includes("(")) {
    return line.substring(line.indexOf("(") + 1, line.indexOf(")"));
  }
  if (line.includes("@")) {
    return line.substring(line.indexOf("@") + 1);
  }
  return line;
}

var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$2 = (obj, key, value) => {
  __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck$1 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$1 = (obj, member, getter) => {
  __accessCheck$1(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$1 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$1 = (obj, member, value, setter) => {
  __accessCheck$1(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _id, _params$1, _creationSite, _name, name_get;
function toInternalRouteRef(resource) {
  const r = resource;
  if (r.$$type !== "@backstage/RouteRef") {
    throw new Error(`Invalid RouteRef, bad type '${r.$$type}'`);
  }
  return r;
}
class RouteRefImpl {
  constructor(params = [], creationSite) {
    this.params = params;
    __privateAdd$1(this, _name);
    __publicField$2(this, "$$type", "@backstage/RouteRef");
    __publicField$2(this, "version", "v1");
    __privateAdd$1(this, _id, void 0);
    __privateAdd$1(this, _params$1, void 0);
    __privateAdd$1(this, _creationSite, void 0);
    __privateSet$1(this, _params$1, params);
    __privateSet$1(this, _creationSite, creationSite);
  }
  getParams() {
    return __privateGet$1(this, _params$1);
  }
  getDescription() {
    if (__privateGet$1(this, _id)) {
      return __privateGet$1(this, _id);
    }
    return `created at '${__privateGet$1(this, _creationSite)}'`;
  }
  setId(id) {
    if (!id) {
      throw new Error(`${__privateGet$1(this, _name, name_get)} id must be a non-empty string`);
    }
    if (__privateGet$1(this, _id)) {
      throw new Error(
        `${__privateGet$1(this, _name, name_get)} was referenced twice as both '${__privateGet$1(this, _id)}' and '${id}'`
      );
    }
    __privateSet$1(this, _id, id);
  }
  toString() {
    return `${__privateGet$1(this, _name, name_get)}{${this.getDescription()}}`;
  }
}
_id = new WeakMap();
_params$1 = new WeakMap();
_creationSite = new WeakMap();
_name = new WeakSet();
name_get = function() {
  return this.$$type.slice("@backstage/".length);
};
function createRouteRef(config) {
  return new RouteRefImpl(
    config == null ? void 0 : config.params,
    describeParentCallSite()
  );
}

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _params, _parent;
const PARAM_PATTERN = /^\w+$/;
class SubRouteRefImpl {
  constructor(path, params, parent) {
    this.path = path;
    __publicField$1(this, "$$type", "@backstage/SubRouteRef");
    __publicField$1(this, "version", "v1");
    __privateAdd(this, _params, void 0);
    __privateAdd(this, _parent, void 0);
    __privateSet(this, _params, params);
    __privateSet(this, _parent, parent);
  }
  getParams() {
    return __privateGet(this, _params);
  }
  getParent() {
    return __privateGet(this, _parent);
  }
  getDescription() {
    const parent = toInternalRouteRef(__privateGet(this, _parent));
    return `at ${this.path} with parent ${parent.getDescription()}`;
  }
  toString() {
    return `SubRouteRef{${this.getDescription()}}`;
  }
}
_params = new WeakMap();
_parent = new WeakMap();
function createSubRouteRef(config) {
  const { path, parent } = config;
  const internalParent = toInternalRouteRef(parent);
  const parentParams = internalParent.getParams();
  const pathParams = path.split("/").filter((p) => p.startsWith(":")).map((p) => p.substring(1));
  const params = [...parentParams, ...pathParams];
  if (parentParams.some((p) => pathParams.includes(p))) {
    throw new Error(
      "SubRouteRef may not have params that overlap with its parent"
    );
  }
  if (!path.startsWith("/")) {
    throw new Error(`SubRouteRef path must start with '/', got '${path}'`);
  }
  if (path.endsWith("/")) {
    throw new Error(`SubRouteRef path must not end with '/', got '${path}'`);
  }
  for (const param of pathParams) {
    if (!PARAM_PATTERN.test(param)) {
      throw new Error(`SubRouteRef path has invalid param, got '${param}'`);
    }
  }
  const subRouteRef = new SubRouteRefImpl(
    path,
    params,
    parent
  );
  return subRouteRef;
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class ExternalRouteRefImpl extends RouteRefImpl {
  constructor(optional, params = [], creationSite) {
    super(params, creationSite);
    this.optional = optional;
    this.params = params;
    __publicField(this, "$$type", "@backstage/ExternalRouteRef");
  }
}
function createExternalRouteRef(options) {
  return new ExternalRouteRefImpl(
    Boolean(options == null ? void 0 : options.optional),
    options == null ? void 0 : options.params,
    describeParentCallSite()
  );
}

function useRouteRef(routeRef) {
  const { pathname } = useLocation();
  const versionedContext = useVersionedContext(
    "routing-context"
  );
  if (!versionedContext) {
    throw new Error("Routing context is not available");
  }
  const resolver = versionedContext.atVersion(1);
  const routeFunc = useMemo(
    () => resolver && resolver.resolve(routeRef, { pathname }),
    [resolver, routeRef, pathname]
  );
  if (!versionedContext) {
    throw new Error("useRouteRef used outside of routing context");
  }
  if (!resolver) {
    throw new Error("RoutingContext v1 not available");
  }
  const isOptional = "optional" in routeRef && routeRef.optional;
  if (!routeFunc && !isOptional) {
    throw new Error(`No path for ${routeRef}`);
  }
  return routeFunc;
}

function useRouteRefParams(_routeRef) {
  return useParams();
}

export { ExtensionBoundary, appTreeApiRef, coreExtensionData, createApiExtension, createExtension, createExtensionDataRef, createExtensionInput, createExtensionOverrides, createExternalRouteRef, createNavItemExtension, createPageExtension, createPlugin, createRouteRef, createSchemaFromZod, createSubRouteRef, createThemeExtension, useRouteRef, useRouteRefParams };
//# sourceMappingURL=index.esm.js.map
