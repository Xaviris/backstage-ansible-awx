/// <reference types="react" />
import * as _backstage_frontend_plugin_api from '@backstage/frontend-plugin-api';
import { AnyExtensionInputMap, ExtensionInputValues, RouteRef } from '@backstage/frontend-plugin-api';
import { Entity } from '@backstage/catalog-model';
import { ResourcePermission } from '@backstage/plugin-permission-common';

/**
 * Returns true if the `owner` argument is a direct owner on the `entity` argument.
 *
 * @alpha
 * @remarks
 *
 * Note that this ownership is not the same as using the claims in the auth-resolver, it only will take into account ownership as expressed by direct entity relations.
 * It doesn't know anything about the additional groups that a user might belong to which the claims contain.
 */
declare function isOwnerOf(owner: Entity, entity: Entity): boolean;

/**
 * Utility type to expand type aliases into their equivalent type.
 * @ignore
 */
type Expand<T> = T extends infer O ? {
    [K in keyof O]: O[K];
} : never;

/**
 * A thin wrapper around the
 * {@link @backstage/plugin-permission-react#usePermission} hook which uses the
 * current entity in context to make an authorization request for the given
 * {@link @backstage/plugin-catalog-common#CatalogEntityPermission}.
 *
 * Note: this hook blocks the permission request until the entity has loaded in
 * context. If you have the entityRef and need concurrent requests, use the
 * `usePermission` hook directly.
 * @alpha
 */
declare function useEntityPermission(permission: ResourcePermission<'catalog-entity'>): {
    loading: boolean;
    allowed: boolean;
    error?: Error;
};

/** @alpha */
declare const entityContentTitleExtensionDataRef: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<string, {}>;
/** @alpha */
declare const entityFilterExtensionDataRef: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<(ctx: {
    entity: Entity;
}) => boolean, {}>;
/** @alpha */
declare function createEntityCardExtension<TInputs extends AnyExtensionInputMap>(options: {
    id: string;
    attachTo?: {
        id: string;
        input: string;
    };
    disabled?: boolean;
    inputs?: TInputs;
    filter?: (ctx: {
        entity: Entity;
    }) => boolean;
    loader: (options: {
        inputs: Expand<ExtensionInputValues<TInputs>>;
    }) => Promise<JSX.Element>;
}): _backstage_frontend_plugin_api.Extension<{
    filter?: {
        isKind?: string | undefined;
        isType?: string | undefined;
    }[] | undefined;
}>;
/** @alpha */
declare function createEntityContentExtension<TInputs extends AnyExtensionInputMap>(options: {
    id: string;
    attachTo?: {
        id: string;
        input: string;
    };
    disabled?: boolean;
    inputs?: TInputs;
    routeRef?: RouteRef;
    defaultPath: string;
    defaultTitle: string;
    filter?: (ctx: {
        entity: Entity;
    }) => boolean;
    loader: (options: {
        inputs: Expand<ExtensionInputValues<TInputs>>;
    }) => Promise<JSX.Element>;
}): _backstage_frontend_plugin_api.Extension<{
    title: string;
    path: string;
    filter?: {
        isKind?: string | undefined;
        isType?: string | undefined;
    }[] | undefined;
}>;

export { createEntityCardExtension, createEntityContentExtension, entityContentTitleExtensionDataRef, entityFilterExtensionDataRef, isOwnerOf, useEntityPermission };
