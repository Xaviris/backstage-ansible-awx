import React, { lazy } from 'react';
import { createExtensionDataRef, createExtension, coreExtensionData, createSchemaFromZod, ExtensionBoundary } from '@backstage/frontend-plugin-api';
import { RELATION_MEMBER_OF, getCompoundEntityRef, stringifyEntityRef, RELATION_OWNED_BY } from '@backstage/catalog-model';
import { g as getEntityRelations, a as useAsyncEntity } from './esm/useEntity-de64059a.esm.js';
import { usePermission } from '@backstage/plugin-permission-react';
import '@backstage/core-plugin-api';
import '@backstage/version-bridge';

function isOwnerOf(owner, entity) {
  const possibleOwners = new Set(
    [
      ...getEntityRelations(owner, RELATION_MEMBER_OF, { kind: "group" }),
      ...owner ? [getCompoundEntityRef(owner)] : []
    ].map(stringifyEntityRef)
  );
  const owners = getEntityRelations(entity, RELATION_OWNED_BY).map(
    stringifyEntityRef
  );
  for (const ownerItem of owners) {
    if (possibleOwners.has(ownerItem)) {
      return true;
    }
  }
  return false;
}

function useEntityPermission(permission) {
  const {
    entity,
    loading: loadingEntity,
    error: entityError
  } = useAsyncEntity();
  const {
    allowed,
    loading: loadingPermission,
    error: permissionError
  } = usePermission({
    permission,
    resourceRef: entity ? stringifyEntityRef(entity) : void 0
  });
  if (loadingEntity || loadingPermission) {
    return { loading: true, allowed: false };
  }
  if (entityError) {
    return { loading: false, allowed: false, error: entityError };
  }
  return { loading: false, allowed, error: permissionError };
}

const entityContentTitleExtensionDataRef = createExtensionDataRef("plugin.catalog.entity.content.title");
const entityFilterExtensionDataRef = createExtensionDataRef("plugin.catalog.entity.filter");
function applyFilter(a, b) {
  if (!a) {
    return true;
  }
  return a.toLocaleLowerCase("en-US") === (b == null ? void 0 : b.toLocaleLowerCase("en-US"));
}
function buildFilter(config, filterFunc) {
  return (ctx) => {
    var _a;
    const configuredFilterMatch = (_a = config.filter) == null ? void 0 : _a.some((filter) => {
      var _a2, _b;
      const kindMatch = applyFilter(filter.isKind, ctx.entity.kind);
      const typeMatch = applyFilter(
        filter.isType,
        (_b = (_a2 = ctx.entity.spec) == null ? void 0 : _a2.type) == null ? void 0 : _b.toString()
      );
      return kindMatch && typeMatch;
    });
    if (configuredFilterMatch) {
      return true;
    }
    if (filterFunc) {
      return filterFunc(ctx);
    }
    return true;
  };
}
function createEntityCardExtension(options) {
  var _a, _b;
  const id = `entity.cards.${options.id}`;
  return createExtension({
    id,
    attachTo: (_a = options.attachTo) != null ? _a : {
      id: "entity.content.overview",
      input: "cards"
    },
    disabled: (_b = options.disabled) != null ? _b : true,
    output: {
      element: coreExtensionData.reactElement,
      filter: entityFilterExtensionDataRef
    },
    inputs: options.inputs,
    configSchema: createSchemaFromZod(
      (z) => z.object({
        filter: z.array(
          z.object({
            isKind: z.string().optional(),
            isType: z.string().optional()
          })
        ).optional()
      })
    ),
    factory({ config, inputs, source }) {
      const ExtensionComponent = lazy(
        () => options.loader({ inputs }).then((element) => ({ default: () => element }))
      );
      return {
        element: /* @__PURE__ */ React.createElement(ExtensionBoundary, { id, source }, /* @__PURE__ */ React.createElement(ExtensionComponent, null)),
        filter: buildFilter(config, options.filter)
      };
    }
  });
}
function createEntityContentExtension(options) {
  var _a, _b;
  const id = `entity.content.${options.id}`;
  return createExtension({
    id,
    attachTo: (_a = options.attachTo) != null ? _a : {
      id: "plugin.catalog.page.entity",
      input: "contents"
    },
    disabled: (_b = options.disabled) != null ? _b : true,
    output: {
      element: coreExtensionData.reactElement,
      path: coreExtensionData.routePath,
      routeRef: coreExtensionData.routeRef.optional(),
      title: entityContentTitleExtensionDataRef,
      filter: entityFilterExtensionDataRef
    },
    inputs: options.inputs,
    configSchema: createSchemaFromZod(
      (z) => z.object({
        path: z.string().default(options.defaultPath),
        title: z.string().default(options.defaultTitle),
        filter: z.array(
          z.object({
            isKind: z.string().optional(),
            isType: z.string().optional()
          })
        ).optional()
      })
    ),
    factory({ config, inputs, source }) {
      const ExtensionComponent = lazy(
        () => options.loader({ inputs }).then((element) => ({ default: () => element }))
      );
      return {
        path: config.path,
        title: config.title,
        routeRef: options.routeRef,
        element: /* @__PURE__ */ React.createElement(ExtensionBoundary, { id, source, routable: true }, /* @__PURE__ */ React.createElement(ExtensionComponent, null)),
        filter: buildFilter(config, options.filter)
      };
    }
  });
}

export { createEntityCardExtension, createEntityContentExtension, entityContentTitleExtensionDataRef, entityFilterExtensionDataRef, isOwnerOf, useEntityPermission };
//# sourceMappingURL=alpha.esm.js.map
